# 简易版RPC框架

rpc框架学习项目

RPC全程是远程过程调用，是一种通信协议。RPC是为了让一台计算机上的程序调用另一台计算机上的程序时，无需了解底层网络传输细节。
直接本地调用一样简单

比如A服务在调用B服务的接口时，A在业务代码中，只需要写一行调用接口的代码即可。
而A服务如何实现向B发起请求，以及如何传递信息，如何接收返回数据，如何再封装好数据返回给调用对象呢？
这些都是RPC框架进行处理的内容

## 雏形案例

在实现RPC框架的过程中，我们先实现一个最简单的案例

新建两个服务AB，A做为服务提供者，B做为服务消费者，然后B要调用A的接口，应该怎么做？

首先两个服务之间是独立的，需要建立连接，A做为服务的提供者，是服务端，需要启动一个服务等待别人的连接

B做为服务的使用方，是客户端，需要连接到服务端。

我们先考虑使用HTTP协议来实现。

这部分代码可以查看本项目中 
- dong-rpc-easy 
- example-consumer 
- example-provider

### 服务端（服务提供者）

A做为服务端，在服务启动后，需要监听一个端口，比如8080，当有客户端连接时，A会接收到请求，然后根据请求的内容，找到对应的接口的实现类，调用服务，返回结果。

A接收到的请求中应该包含客户端要调用的接口名字

A本地要维护一份字典，比如接口A，它对应的实现类是哪一个

A知道对应的实现类之后，就可以利用反射的机制执行接口，如下：
```java
//先找实现类
Class<?> implClass = LocalRegistry.get(rpcRequest.getServiceName());
//具体类里的哪个方法
Method method = implClass.getMethod(rpcRequest.getMethodName(), rpcRequest.getParameterTypes());
//执行
Object result = method.invoke(implClass.newInstance(), rpcRequest.getArgs());
```

### 客户端（服务消费者）

B做为客户端，在代码中去调用接口的时候，要做哪些事情

B拿到接口后，要知道调用的接口所在是哪个服务，对方提供的IP端口是多少。

B需要主动发起HTTP请求，组装信息，然后接收返回数据

### RPC框架代理

#### 雏形

当这两部分代码完成后，我们会看到，一个接口的调用具体要做的内容简单来说就是这些。
然后当接口的数量变多之后，B每次调用接口，都要去组装HTTP请求
然后A这边我们发现，也是每次拿到接口名字去寻找接口实现类并执行

同时，这两部分的处理逻辑和业务都是没有任何联系的，且都是公共的部分，就是每调用一次接口，都需要做这些内容，
这个时候，我们就可以将代码抽离出来，封装为一个一个的能力，具体来说有以下几个

启动服务端并监听端口（接口提供者）

接口和实现类的映射关系存储（接口提供者）

实现类并执行的能力（接口提供者）

发请求的能力（给消费端用）

把上面这些内容封装在一起，就基本组成了RPC框架的雏形

#### 发请求能力拆分

上面说到的发请求的能力，又分为几步

第一步：我们为每个接口都写一个代理接口，比如调用接口a，就写一个代理a，每次调用a的时候，其实都是调用代理a，然后由代理完成具体发请求的内容

第二步：随着接口的数量增加，我们要为很多接口都写代理，就比较麻烦，这时候就要引入**动态代理**，通过代理工厂来根据实际的类创建动态的代理类
```java
return (T) Proxy.newProxyInstance(
                serviceClass.getClassLoader(),
                new Class<?>[]{serviceClass},
                new ServiceProxy()
        );
```
如上述代码，通过Proxy.newProxyInstance方法创建了一个动态代理类，而ServiceProxy是这个动态代理类的处理器，它实现了InvocationHandler接口，这里面是真正执行发请求的部分


## 进阶扩展

这部分内容具体的文档可以看本项目 /doc 文件夹下的文档

### 全局配置

### 接口MOCK

### 序列化器和SPI机制

### 注册中心

### 自定义协议

### 负载均衡

### 重试

### 容错


